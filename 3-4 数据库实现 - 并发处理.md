#### 3-4 数据库实现 - 并发处理

1. 事务
   一串指令集合，不可分割，要么做完要么不做。
   是并发控制和恢复的基本单位。

2. 事务特性：ACID
   1. 原子性：完全(不)执行。
   2. 一致性：不能出现丢失修改、不能重复读（脏读）。
   3. 隔离性：两个事务并发执行，不出现和串行不同的结果。
   4. 持久性：影响持久，被撤销可恢复。

3. 读写函数
   1. INPUT/OUTPUT：缓冲区管理器控制，与磁盘交互。
   2. READ/WRITE：事务发出。

4. 调度：事务动作的R/W安排序列。

5. 串行调度$\subseteq$冲突可串行化调度$\subseteq$可串行化调度$\subseteq$正确的调度

6. 串行调度：先执行A全部动作，再执行B全部动作。

7. 可串行化调度：多个事务的并行调度序列对于数据库的影响等价于对这些事务的一个串行调度，称这个并行调度为可串行化调度。

8. 什么样的调度是可串行化的调度？必要条件：**冲突可串行化调度**：满足冲突可串行化的调度，一定是可串行化的调度，反之不然。一个调度，如果通过交换**没有冲突**的动作能够变成一个串行调度，则称为冲突可串行化调度。

9. 冲突：指一对事务动作，不能调换顺序。
   1. 同一事务的任意两个动作都冲突。
   2. 不同事务对同一数据的写是冲突的。
   3. 不同事务对同一数据的一读一写是冲突的。

10. 冲突等价：调度之间的一种关系，如果一个调度可以交换没有冲突的动作变成另一个调度，称这两个调度冲突等价。

11. 冲突可串行性判别算法（优先图）
    1. 绘制这样的一个图：每一个事务都有一个结点，对事务1内部的某个动作A，如果和事务2的某个动作B存在冲突（不可交换），且A在B前发生，则画一条1到2的边。
    2. 如果图中没有环，则是冲突可串行化的。

12. 并发控制协议

    1. 基于锁的协议：延迟操作
    2. 基于时间戳的协议：拒绝错误操作、不会死锁
    3. 多版本机制：保留多个版本

13. 基于锁的并发控制：需要保证串行和解决死锁

    两段锁的调度是冲突可串行的调度，反之不然，即存在某个冲突可串行的调度没有对应的两段锁调度。

    解决方案：

    1. 保证串行：两段锁
    2. 解决死锁：两种方式
       1. 预防死锁不让发生：一次封锁法、顺序封锁法
       2. 发生后恢复死锁：事务超时、定时绘制等待图
    3. 锁的概念
       1. 锁：锁定数据项，分为共享锁S和互斥锁X。
          被S锁上的数据项能再被S锁锁上，其他情况都不能再被锁上。
       2. 加锁和解锁的事务动作：LOCK-S(A)、LOCK-X(A)、UNLOCK(A)
       3. 事务想读数据项，必须有S/X锁，想写数据项必须有X锁。否则只能等待别人解锁才能访问。
       4. 单独的锁不能保证调度可串行性！需要两段锁才能保证。
    4. 死锁：两方在占用自身资源的同时，请求对方资源。造成无限的等待。
       1. 预防死锁：
          1. 一次封锁：一次性要用的数据全部加锁。问题：降低系统并发度、难于事先确定数据。
          2. 顺序封锁：预先对数据对象确定一个封锁顺序，所有事务都按照这个顺序来。问题：数据频繁更新变化大，维护成本高，难以实现；
       2. 死锁恢复：
          1. 超时：容易误判死锁、时间太长不能及时发现
          2. 等待图：事务为结点，A等待B则A有边指向B，如果出现环则出现死锁。
          3. 选择牺牲者，使回滚代价最小。（彻底回滚、部分回滚、回滚时还可能牵扯其他事务）
          4. 饿死：有一个事务总被选为牺牲者，总不能执行，需要设定选择的上限。
    5. 两段锁：可串行化的事务调度不能随意加解锁，分为加锁阶段和解锁阶段。
       1. 加锁阶段只能加锁或将S锁升级为X锁。
       2. 解锁阶段只能解锁或将X锁降级为S锁。
       3. 初始在加锁阶段，第一次降级或解锁即进入解锁阶段。
       4. 升级降级事务动作：UPGRADE、DOWNGRADE

14. 基于时间戳的并发控制

    1. 时间戳：可以是系统时钟，也可以是逻辑计数器。只需要保证随着事务的发生而增长即可。
    2. 每个事务都有一个时间戳，且后来的事务时间戳大于先来的事务。
    3. 每个数据项都有两个时间戳值关联：R/W-timestamp，分别对应成功执行read/write的最大时间戳。
    4. 读操作：t<wt，则拒绝、回滚，因为请求的值已被覆盖；否则可以读。
    5. 写操作：t<rt，则拒绝且回滚，因为所需的值已被取走；t<wt，则无需继续，直接忽略，因为已被覆盖；其他情况可以写。

15. 多版本控制

    1. 可以和锁、时间戳分别结合使用。
    2. 每次写创建一个数据项的新版本。
    3. 每次读根据事务的开始时间选择一个合适的版本。
    4. 多版本时间戳排序机制
       1. 每个数据项有多个版本，每个版本有版本号和R/W-timestamp，分别表示当前版本创建的时间戳、成功读取当前版本事务的最大时间戳。
       2. 读写：选择距离事务开始时间最近的数据项创建时间对应的版本Qk。
          1. 读：返回Qk
          2. 写：
             1. 如果t<Rt(Qk)，则回滚，因为版本已经被读了，且不是自己写的，不能覆盖写。
             2. 如果t=Wt，则覆盖，因为是自己写的。
             3. 否则创建一个新版本。
       3. 删除无用旧版本：删除系统中运行的最老事务对应的版本的**前一个**版本。（对应的版本是指事务开始时间前最近的版本）
       4. 优点：读不等待且不失败
          缺点：更新Rt存在潜在的2次磁盘访问、事务冲突回滚开销大、不保证可恢复和无级联
