#### 3-1 数据库实现 - 物理存储结构

1. 物理存储介质

   高速缓存、主存、闪存、磁盘、光盘、磁带

2. 磁盘

   1. 磁盘组、磁道、扇区（磁盘块、页）、柱面
   2. 磁盘驱动、磁头、磁臂
   3. 与主存以（磁盘块）页为单位交换
   4. 寻址：盘面、柱面、扇区
   5. 寻道时间+旋转延迟+传输延迟

3. 磁盘缓冲技术

   1. 在主存中设置多个缓冲区，每个缓冲区大小为一块（页），处理一个块的时候读下一个块。
   2. 每个缓冲块有：dirty和pin_count两个值。
      dirty表示是否被修改，需要写回。
      pin_count为当前正在使用该块的事务计数
   3. 缓冲区满需要选块被替换，选择pin_count=0的，如果没有，则放弃事务，否则根据策略选择一个：LRU、MRU、立即丢弃（用完就写回）等。
   4. 事务处理策略
      1. 先来先服务
      2. 近者优先：优先处理离磁头最近的
      3. 全程移动扫描：扫描磁道，从0到最大顺序循环处理
      4. 移动扫描：扫描磁道，前进方向没有请求则反向。
      5. 分组扫描：按照分组
      6. 间歇式扫描：每个柱面停止等待磁盘旋转n次。

4. 磁盘容错技术（RAID）

   1. RAID1：每个磁盘一个冗余盘，数据同步。
   2. RAID4：多个磁盘一个冗余盘，只存奇偶校验位。某个磁盘坏了通过其他磁盘数据可以推出。
   3. RAID5：4的冗余盘容易坏，改成每个磁盘若干扇区存奇偶校验位。

5. 文件和关系

   1. 数据项——属性值（及其类型）

   2. 文件记录——元组（可选定长/非定长、可选允许跨块存储）

   3. 文件块（磁盘块）——多个元组

      记录固定的文件块：直接指针，修改复杂

      非固定记录的文件块：2级间接指针，修改快。

   4. 文件——关系

      存储方法：连续（磁盘块）、连接（链表）、索引。

6. 简单HASH文件

   1. 用散列函数计算指定的哈希属性，得到哈希值，查表，放入表项对应磁盘块中，如果不够，新建磁盘块，旧磁盘块指向下一个新的磁盘块。
   2. 查找：哈希属性算值查表，否则全表查询
   3. 插入：如1.
   4. 删除：已知hash值，反向1，释放磁盘块。否则全表查询。
   5. 缺点：哈希函数不变，文件记录增多，效率降低。对较少文件记录的关系，浪费空间。

7. 动态HASH文件：

   1. 可扩展Hash文件
      1. 桶目录：指向桶的指针，初始d=1即2个桶目录项指向2个桶，（桶没满则可能两个指针指向一个桶），如果满了才指向单独的桶。
      2. 每一个hash值的前d位用于表示桶号。d随数据量自动增长：初始为1，之后没有地方存桶了（目录满了）就+1，即桶目录数翻倍。每个桶都有单独的d。
      3. 桶满了先指针裂开，指针不够了桶目录才裂开，桶目录裂开d+1。
      4. 优点：查找记录时只查找一个存储块。
      5. 缺点：内存波动大，桶目录裂开要翻倍，指数增长。
   2. 线性HASH文件
      1. 使用溢出桶，保证线性增长。
      2. n为桶数，给定b、$\theta \in (0,1)$，表中最多容纳nb$\theta$个记录。每个桶最多b个记录。
      3. $m=2^{\lfloor{log_2n}\rfloor}$，$m\le n< 2m$
      4. 某个记录k的哈希值为h，其桶号如下计算：
         1. 如果i = h mod 2m < n，则桶号为i；
         2. 否则桶号为h mod m；（可能会存入溢出桶）
         3. 当存入的记录超过nb$\theta$后，桶数n增加1，重新计算当前分裂的桶各记录的桶号。
         4. 哪个桶要分裂？见作业2倒数第二题。

8. 索引文件

   1. 通常是有序文件，索引文件的记录为索引项包括两个域：搜索码（索引的值），原始记录地址。
   2. 通常按照搜索码大小排序，索引文件一般远小于数据文件。
   3. 多级索引：为索引文件增加索引；
      稀疏索引：所有记录中分组，每组只有一个索引项，更新代价高；
      稠密索引：每个记录都有个索引，空间复杂性大；
      聚集主索引：主码为搜索码，有序，一般为稀疏索引，每个索引项对应一个磁盘块，频繁更新不要使用；
      辅助索引：必须为稠密索引，每个索引值都有个索引项（记录数与原始记录相等），排序，如果搜索码不是候选码，必须包含（可能多个同值）指向记录的指针。
   4. B+树索引：参数n
      1. 每个节点n个指针，n-1个值，值为右子树的最小值。每个节点不能少于$\lfloor n/2 \rfloor$个子女（根节点不能少于2个），满了需要分裂。
      2. 叶节点指针：数据记录指针只在叶节点上，且在值的左侧。叶节点的最后一个指针指向兄弟节点。
      3. 内节点指针：值右侧的指针指向以该值为子树最小值的子树根。
      4. 插入时，如果叶节点已满，需要分裂，前n/2分一半，后n/2分一半，插入的值要选择一个节点加入。父节点要更新指针，如果已满，也要分裂，保证值为右子树的最小值，直到根节点分裂，增加一层，新的根结点。
      5. 删除时，如果记录项少于$\lfloor n/2\rfloor$，需要合并结点，父节点删除索引项，父节点少了同样要和兄弟合并，可能直到根节点。