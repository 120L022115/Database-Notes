#### 3-5 数据库实现 - 恢复机制

1. 确保系统发生故障后，能恢复到正确的状态。
2. 目的：保证事务原子性、确保数据库的恢复正确状态。
3. 故障：
   1. 事务故障（逻辑故障：溢出、系统错误：死锁）
   2. 系统崩溃：硬件故障、内存丢失
   3. 磁盘故障
4. 日志恢复技术
   1. 日志记录格式
      1. 开始事务 <T, start>
      2. 提交事务 <T, commit>
      3. 终止事务 <T, abort>
      4. 可恢复的更新事务 <T, X, vold, vnew>
      5. 不可恢复的更新事务 <T, X, vnew>
   2. 日志被永久存储在磁盘上，记录事务的数据库操作。
   3. 事务开始时，写start日志
   4. 事务部分提交前，写commit日志
   5. 事务更新数据前，写更新操作日志
   6. 主要有两种方式：推迟更新、即时更新
5. 推迟更新的日志恢复
   1. 事务执行分为两个阶段：日志记录阶段、部分提交阶段，分割点是提交点。	
      1. 在事务执行时候，每一个写操作对应一个不可恢复的更新事务日志。
      2. 所有数据库更新推迟到事务提交时执行，在到达提交点之前不能更新数据库。
      3. 在事务的所有日志没有被永久写入存储器之前，事务不能到达提交点。
   2. 恢复方法：通过redo重做解决任何非永久存储器信息的丢失问题。
      1. redo(T)：对每个关于T的记录，更新为vnew。redo操作是幂等的，执行多次和一次效果相同。
      2. 确定需要redo的事务：当且仅当日志包含<T,start>和<T,commit>
      3. 执行过程：
         1. 从后向前扫描整个日志记录，维护两个事务表：提交事务表和尚未提交事务表
         2. 对提交事务表中的事务执行Redo，对未提交事务写入abort记录（？删除所有有关记录）。
6. 即时更新的日志恢复
   1. 允许事务直接更新数据库，但要保证日志先写入，且附带两个值（可恢复的日志记录）。
      1. 所有写日志安全的永久存储之前，事务不能更新数据库。
      2. 所有写日志安全的永久存储之前，事务不能提交。
   2. 恢复方法：通过redo和undo来实现。
      1. undo(T)：对每一个T的可恢复记录，恢复为vold。是幂等的。
      2. 执行过程：
         1. 从后向前扫描全部日志，建立两个表：未提交的、已提交的（和推迟一样）
         2. 对提交事务表执行Redo。对未提交事务执行undo，并写一个abort记录，表示撤销完成。
         3. 当执行undo操作的时候，写一个特殊的只读不可恢复日志记录<Ti,X,Vnew>，表示恢复完成，该记录无需undo，只undo四元组。
7. 检查点技术
   1. 日志全部运行，太长了，引入检查点。
   2. 检查点的写入要保证之前的日志都被成功写入磁盘，所有缓冲块也写到磁盘。
   3. 检查点执行过程中，不允许任何事物进行更新
   4. 用< checkpoint L >表示检查点，L是正活跃的事务列表（已开始尚未提交的）
   5. 检查点可以按需建立，如定期或不定期（按日志文件大小）
   6. 对检查点前的事务，无需进行redo，但可能进行undo
   7. 恢复方法：
      1. 找到最后一条检查点记录。对L中的事务及检查点之后才开始的事务进行操作：如果找到了commit或abort，则执行undo，否则执行redo。
      2. 执行过程：重做阶段、撤销阶段
         1. 重做阶段
            1. 找到最新的检查点，将undolist设为L。
            2. 从检查点向下扫描，遇到可恢复或不可恢复的日志记录，都进行redo。
            3. 发现start，将该事务加入undolist。
            4. 发现commit或abort，从undolist删除。
         2. 撤销阶段
            1. 从**最后向前**扫描日志，发现属于undolist的事务，就执行undo操作：恢复值、写一个不可恢复日志记录。
            2. 发现start，说明找到了该事务的开始位置，从undolist删除该事务，并写一个abort。
            3. 一旦undolist为空，说明所有应该undo的事务都被成功解决，这有可能越过checkpoint。
8. 日志缓冲技术
   1. 在主存设立缓冲区，大小等于永久存储器的读写单位（磁盘块），满了再写。
      1. 任何事务必须在commit日志记录写入永久存储器之后才可以进入提交状态。
      2. 任何事务的非commit记录要在commit记录之前写入永久存储器（不能同时）。
      3. 要在所有主存日志记录写入存储器之后，再写入存储器的数据库。
   2. 数据块替换：如果旧块被修改，则需要先将旧块数据对应的日志永久写入存储器，再将旧块数据写入存储器，之后才能提取新块。
