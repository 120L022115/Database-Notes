 

#### 2-2 数据库设计 - 逻辑数据库

1. 逻辑数据库设计：形成初始关系模式$\to$关系模式规范化

2. 形成初始关系模式：
   1. 普通实体集的变换：复合属性不要，只要简单子属性、实体的码是关系的主码。
   2. 弱实体的变换：关联的属性主码加入关系，与本实体的部分码组成主码。
   3. 多值属性变换：单独建立一个关系，所有值附加原关系的主码作为主码。
   4. 1:1联系变换：在任意一方实体集中增加一个对方的主码作为外码，描述性属性同时加入，尽量选择被全域约束的实体添加。
   5. 1:n联系变换：将1的主码放入n中作为外码，描述性属性同时加入。
   6. m:n联系变换：建立一个新关系，包含两个的主码。
   7. n元联系变换：建立一个新关系，包含n个主码。

3. 初始关系模式存在的问题：
   1. 插入异常：存在因约束性无法加入相对完整的新内容的情况。
   2. 删除异常：存在因删除元组导致其他信息被删除的情况（无法单独删除元组部分属性）。
   3. 数据冗余、更新问题

4. 关系模式规范化：
   1. 确定函数依赖集
      1. 函数依赖
         1. X$\to$Y $\iff$ t为元组，$\forall t_1[X]=t_2[X] \to t_1[Y]=t_2[Y] $，X为Y的决定属性集
         2. 非平凡依赖：Y不是X的子集
         3. 平凡依赖：Y是X的子集
         4. 完全依赖：X任意一个真子集都不成立
         5. 部分函数依赖：不完全依赖
         6. 传递函数依赖：Z-X/Z-Y/Y-X不空，Y$\to$X不成立，则$X\to Y,Y\to Z \Rightarrow X\to Z$
         7. 超码：设U为属性全集，$K\to U$
         8. 候选码：完全依赖
         9. 主码：选择的一个候选码
         10. 键属性：是候选码的属性
         11. 全键：候选码包含所有属性
      2. Armstrong公理系统
         1. 逻辑蕴含：能够通过公理推导
         2. 三个公理：
            1. 自反律：$Y\subseteq X \subseteq U,  \Rightarrow X\to  Y$
            2. 增广律：$X\to Y, Z\subseteq U \Rightarrow XZ\to YZ$
            3. 传递律：$X\to Y, Y\to Z \Rightarrow X\to Z$
         3. 导出规则：
            1. 合并规则：$X\to Y, X\to Z \Rightarrow X\to YZ$
            2. 伪传递规则：$X\to Y, YW\to Z \Rightarrow XW\to Z$
            3. 分解规则：$X\to Y, Z\subseteq Y \Rightarrow X\to Z$
            4. 引理6.1：$X\to A_1A_2A_3... \iff \forall i, X\to A_i 成立$
         4. 依赖集F的闭包：$F^{+} = \{A\to B | \forall (C\to D) \in F \Rightarrow^* (A\to B)\}$
         5. **（算法必考）**属性X关于依赖集F闭包：$X^+_F = \{X,B|(X\to B )\in F^+ \}$
         6. 属性依赖集的计算方法，PPT。

   2. 求解候选码（算法PPT，必考）

      四类属性：L、R、N、LR，仅L\N一定为候选键，R一定不是，LR不一定。

      当其属性依赖集闭包为U时，为候选码。

   3. 极小函数依赖集（不唯一）

      1. 定义：右部仅有一个符号、每一个都是完全依赖、少一个都不行。
      2. 求解：
         1. 去掉左部无用，变为完全依赖
         2. 右侧变为一个属性
         3. 检查能否被取代

   4. 规范关系模式
      1. 第一范式：关系表
      2. 第二范式：非键完全依赖于候选键：候选键为左部，一个都不能少。
      3. 第三范式：非键不传递依赖于候选键
      4. BC范式：键不传递依赖
      5. BCNF的性质

         达到了函数依赖范畴最高规范形式

         所有非键属性都完全依赖于每个候选码；

         所有键属性都完全函数依赖于每个不包含它的候选码；

         没有任何属性函数依赖于非键的任何一组属性。

5. 通常要求：静态关系（只读）具有第一范式，动态关系具有第三范式

6. 关系模式分解的约束：

   1. 分解：属性并集为原模式属性、子表属性之间不存在包含关系
   2. 无损连接性：子表自然连接后于原表相同
   3. 函数依赖保持性：子表函数依赖集求并与原表等价

7. 算法：无损连接性的判断

   1. 画表法（任意条件）：
      1. 初始化表格：行头为目标子表，每行一个子表。列头为属性列表，每列一个属性。表项值为：若行头中有列则为$a_{列号}$，否则为$b_{行号||列号}$。
      2. 对每一个函数依赖进行运算：判断左部所在列的某些行的值是否相同（单列内进行匹配），如果相同，将右部所在列的这些行的值进行替换：替换为相同的（从原来的行中选），有a优先换a。
      3. 如果最终存在一行a，即无损，因为没有分解的时候就是一行a。
   2. 公式法（仅2个子表）
      1. $(U_1 \cap U_2 \to U_1-U_2)\in F^+$或$(U_1 \cap U_2 \to U_2-U_1)\in F^+$ 则无损。
      2. 证明：见笔记。

8. 算法：判断保持函数依赖

   1. 依次求子表的依赖，求并即可。

9. 3NF的分解算法

   1. 保持函数依赖且3NF

      使用**极小函数依赖集**：每个依赖一个表：左部为主键、右部为非键属性。

   2. 保持函数依赖且**无损**3NF

      增加一个原关系的任意一个候选键组成的关系，如果被子表包含，则无需增加。

10. 关系模式优化

    1. 水平分解：一部分元组、一部分元组。如：学生关系分为计算机学生和航天学生
    2. 垂直分解：分解属性到不同的表。缺点：查大表要连接。
       1. 必须满足无损连接性和保持函数依赖

11. 定义完整性约束和安全性约束

12. 定义子模式（视图）

13. 性能估计：要会算

    1. 逻辑存取数的估算：求和(频率$\times$访问记录数)
    2. 信息传输量的估算：求和(记录长度$\times$频率$\times$访问记录数)
    3. 存储空间占用量的估算：所有关系求和(关系模式记录长度$\times$记录数)